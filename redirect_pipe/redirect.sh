#!/usr/bin/env bash

echo '### redirect ###'

# [基本]
#
# リダイレクトの仕組みについては下記の説明が分かりやすい
# [プログラムの出力をリダイレクトする](https://blog.ingage.jp/entry/2018/06/19/104313)
#
# リダイレクトの指定があると、シェルは以下のような準備をしてから指定されたコマンドを起動する
# int fd = open("/tmp/foo", O_WRONLY);  # 指定されたファイルを開く
# dup2(fd, 1);                          # fdの代わりにディスクリプタ1でも書き込み可能とする
# write(fd, "123", 3);                  # これら2つは同じファイルに書き込む
# write(1, "123", 3);

# ls > hoge.txtならば以下となる
# int fd = open("./hoge.txt"...)
# dup2(fd, 1)
# write(...)
ls > success.txt
# [>]の部分は[1>]としても挙動は変わらない。
# と言うか、[>]は[1>]の省略形である。
ls 1> success.txt  # 本来はこうなっている

# [エラー出力]
# 標準エラー出力のファイルディスクリプタは[2]

# ありえないディレクトリをlsに与えると画面にエラーメッセージが表示される
ls aaa
# write(1, 標準出力)
# write(2, 標準エラー出力)
# 両方とも画面に表示されるので見た目は区別できないが、プログラム的には別々のファイルとして扱っている

# lsは複数のディレクトリを指定できるので、１つは実際に存在するディレクトリ、もう一つは存在しない
# ディレクトリを指定してみる
ls . aaa
# .のリスト
# aaaのエラーメッセージ
# 両方が画面に表示される

# 先に述べたように標準出力と標準エラー出力は別々に管理されているので、それぞれを別々のファイル
# にリダイレクトしてみる
ls . aaa > success.txt 2> error.txt
# こうすると、success.txtには[.]の一覧、error.txtには[aaa]のエラーメッセージが出力されている
#
# シェルは大雑把に、以下のようなことをやっている
# [標準出力]
# int fd1 = open("./success.txt"...)
# dup2(fd1, 1)
# write(...)
#
# [標準エラー出力]
# int fd2 = open("./error.txt"...)
# dup2(fd2, 2)
# write(...)

# 標準出力と標準エラー出力を同じファイルに出力する場合は以下のようにする
ls . aaa > result.txt 2>&1
# 仮に2>&1の部分を2>1にすると、単にファイル1に標準エラー出力がリダイレクトされたことになる
ls . aaa > result.txt 2>1
# なので、[2>&1]の'&'は理屈で考えるのではなくて、「単にそのような仕様とした」との理解で良いと思われる

ls . aaa > result.txt 2>&1
# この場合、シェルは、
# [標準出力]
# int fd1 = open("./result.txt"...)
# dup2(fd1, 1)     # 標準出力(1)の出力先をfd1と同じにする(result.txt)
# write(...)
#
# [標準エラー出力]
# dup2(1, 2)       # 標準エラー出力(2)の出力先を標準出力と同じにする(result.txt)
# write(...)
#
# となる。

# よくある間違い1
ls . aaa 2>&1 > result.txt
# これはシェル的には
#
# [標準エラー出力]
# dup2(1, 2)       # 標準エラー出力(2)の出力先を標準出力と同じにする(画面に出力)
# write(...)
#
# その後標準出力の出力先変更
# int fd1 = open("./result.txt"...)
# dup(fd1, 1)      # この時点で標準出力の出力先がresult.txtになる
# write(...)
#
# のような処理の流れになるので、結果として
# 標準エラー出力： 画面
# 標準出力:       result.txt
# となってしまう。

# よくある間違い2
# wordが保存されているword.txtを読み込みbをBに置換するいとで以下のようにしたとする。
echo 'aaa bbb ccc' > word.txt
tr b B < word.txt > word.txt

# 結果、word.txtは空になる。
# シェル的には、
#
# 標準出力のリダイレクト先のファイルを書き込みモードでオープン
# この時点で元のファイルアは空になる
# int fd1 = open("./word.txt", "w")
# dup(fd1, 1)      # この時点で標準出力の出力先がresult.txtになる
#
# 「< word.txt」は、空のファイルを読み込むことになるので、結果的にworld.txtは空ファイルになる

echo 'aaa bbb ccc' > word.txt
tr b B < word.txt >> word.txt
# これならばword.txtには処理結果が追加されるので、空にはならない
# が、本来の目的(置換)とは違うと思われる
# 「>>」の場合、シェルは
# int fd1 = open("./word.txt", "a")   # アペンドモードでファイルをオープン
# となる。(で良かったんだったっけ？ ひょっとしたら間違っているかも知れないが、ニュアンスはそんな感じ)

# clean up
rm 1
rm *.txt
